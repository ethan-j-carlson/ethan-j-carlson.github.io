//https://www.w3schools.com/js/js_json.asp
//This dictionary was generated programmatically with Python
var tipo_graphemes = {
    " ": " ",
    "0": "\u2198",
    "1": "\u02e9",
    "2": "\u02e8",
    "3": "\u02e7",
    "4": "\u02e6",
    "5": "\u02e5",
    "6": "\u2193",
    "7": "\u2191",
    "9": "\u2197",
    "A": "\u0251",
    "A)": "\u0252",
    "E": "\u025b",
    "E\"": "\u025c",
    "E)": "\u0153",
    "I": "\u026a",
    "I\"": "\u0258",
    "O": "\u0254",
    "O\"": "\u025e",
    "O(": "\u028c",
    "U": "\u028a",
    "Y": "\u028f",
    "@": "\u00e6",
    "*": "*",
    "*+": "\\\\",
    "*-": "\u034d",
    "*%": "\u0311",
    "*_": "\u0362",
    "*=": "\u0333",
    "*H": "\u207c",
    "*W": "\u02ac",
    "*M": "\uf07d",
    "*G": "\uf005",
    "*K": "\uf004",
    "*P": "\u00a1",
    "*>": "\u0354",
    "*<": "\u0355",
    "*R": "\u2180",
    "*\"": "\u0348",
    "*.": "\u0349",
    "*)": "\u208e",
    "*(": "\u208d",
    "*B": "\u02b1",
    "*C": "\u0330",
    "*N": "\uf006",
    "*D": "\u034a",
    "*L": "\uf07c",
    "*V": "\u2193",
    "*|": "\u034e",
    "*X": "\uf003",
    "*F": "\u02a9",
    "*~": "\u034c",
    "*T": "\u02ad",
    "*S": "\ua78e",
    "*Z": "\uf035",
    "?": "\u0294",
    "?;": "\u02a2",
    "?+": "\u02a1",
    "?H": "\u0295",
    "'": "\u02bc",
    "'+": "\u02d6",
    "'-": "\u207b",
    "'%": "\u0311",
    "';": "\u02d5",
    "',": "\u030d",
    "'_": "\u02fd",
    "'H": "\u02b0",
    "'W": "\u02b7",
    "'M": "\u033c",
    "'J": "\u02b2",
    "'G": "\u02e0",
    "'P": "\u02e4",
    "'!": "\u1df5",
    "'>": "\uab6a",
    "'<": "\uab6b",
    "'R": "\u02de",
    "'\"": "\u0308",
    "'`": "\u031a",
    "')": "\u0357",
    "'(": "\u0351",
    "'B": "\u02b1",
    "'C": "\u0330",
    "'N": "\u207f",
    "'D": "\u0346",
    "'=": "\u033b",
    "'L": "\u02e1",
    "'|": "\u0334",
    "'X": "\u033d",
    "'F": "\u030a",
    "'V": "\u030c",
    "'~": "\u0303",
    "^": "^",
    "^+": "\u02d6",
    "^-": "\u02d7",
    "^%": "\u1d54",
    "^;": "\u02d5",
    "^,": "\u02c8",
    "^_": "\u02fd",
    "^H": "\u02b0",
    "^W": "\u02b7",
    "^M": "\u033c",
    "^J": "\u02b2",
    "^G": "\u02e0",
    "^P": "\u02e4",
    "^!": "\u02d4",
    "^>": "\uab6a",
    "^<": "\uab6b",
    "^R": "\u02de",
    "^\"": "\u00a8",
    "^`": "\u02fa",
    "^)": "\u02d2",
    "^(": "\u02d3",
    "^B": "\u02b1",
    "^C": "\u0330",
    "^N": "\u207f",
    "^D": "\u032a",
    "^=": "\u25ab",
    "^L": "\u02e1",
    "^|": "\u0334",
    "^X": "\u02e3",
    "^F": "\u02f3",
    "^V": "\u02ec",
    "^~": "\u02dc",
    "/": "/",
    "/+": "\u031f",
    "/-": "\u0320",
    "/%": "\u032f",
    "/;": "\u031e",
    "/,": "\u0329",
    "/_": "\u033a",
    "/H": "\u2095",
    "/W": "\u02b7",
    "/M": "\u033c",
    "/J": "\u2c7c",
    "/G": "\u1d67",
    "/P": "\u209a",
    "/!": "\u031d",
    "/>": "\u0318",
    "/<": "\u0319",
    "/R": "\u02de",
    "/\"": "\u0324",
    "/`": "\u0349",
    "/)": "\u0339",
    "/(": "\u031c",
    "/B": "\u0324",
    "/C": "\u0330",
    "/N": "\u2099",
    "/D": "\u032a",
    "/=": "\u033b",
    "/L": "\u2097",
    "/|": "\u0334",
    "/X": "\u2093",
    "/F": "\u0325",
    "/V": "\u032c",
    "/~": "\u0330",
    ".": ".",
    ".+": "\u02d0",
    ".-": "\u02d1",
    ".%": "\u0306",
    ".`": "\u02c8",
    ".,": "\u02cc",
    ".:": "\u2016",
    ".|": "|",
    "._": "\u035c",
    ".=": "\u0361",
    ".(": "\u2040",
    ".)": "\u203f",
    "\\ ": " ",
    "\\!": "!",
    "\\\"": "\"",
    "\\#": "#",
    "\\$": "$",
    "\\%": "%",
    "\\&": "&",
    "\\'": "\\'",
    "\\(": "(",
    "\\)": ")",
    "\\*": "*",
    "\\+": "+",
    "\\,": ",",
    "\\-": "-",
    "\\.": ".",
    "\\/": "/",
    "\\0": "0",
    "\\1": "1",
    "\\2": "2",
    "\\3": "3",
    "\\4": "4",
    "\\5": "5",
    "\\6": "6",
    "\\7": "7",
    "\\8": "8",
    "\\9": "9",
    "\\:": ":",
    "\\;": ";",
    "\\<": "<",
    "\\=": "=",
    "\\>": ">",
    "\\?": "?",
    "\\@": "@",
    "\\A": "A",
    "\\B": "B",
    "\\C": "C",
    "\\D": "D",
    "\\E": "E",
    "\\F": "F",
    "\\G": "G",
    "\\H": "H",
    "\\I": "I",
    "\\J": "J",
    "\\K": "K",
    "\\L": "L",
    "\\M": "M",
    "\\N": "N",
    "\\O": "O",
    "\\P": "P",
    "\\Q": "Q",
    "\\R": "R",
    "\\S": "S",
    "\\T": "T",
    "\\U": "U",
    "\\V": "V",
    "\\W": "W",
    "\\X": "X",
    "\\Y": "Y",
    "\\Z": "Z",
    "\\[": "[",
    "\\\\": "\\\\",
    "\\]": "]",
    "\\^": "^",
    "\\_": "_",
    "\\`": "`",
    "\\a": "a",
    "\\b": "b",
    "\\c": "c",
    "\\d": "d",
    "\\e": "e",
    "\\f": "f",
    "\\g": "g",
    "\\h": "h",
    "\\i": "i",
    "\\j": "j",
    "\\k": "k",
    "\\l": "l",
    "\\m": "m",
    "\\n": "n",
    "\\o": "o",
    "\\p": "p",
    "\\q": "q",
    "\\r": "r",
    "\\s": "s",
    "\\t": "t",
    "\\u": "u",
    "\\v": "v",
    "\\w": "w",
    "\\x": "x",
    "\\y": "y",
    "\\z": "z",
    "\\{": "{",
    "\\|": "|",
    "\\}": "}",
    "\\~": "~",
    "a": "a",
    "a\"": "\u0250",
    "a)": "\u0276",
    "b": "b",
    "b<": "\u0253",
    "b!": "\u0298",
    "bB": "\u0299",
    "bH": "\u03b2",
    "c": "c",
    "c<": "\u0284",
    "c!": "\u01c2",
    "cH": "\u00e7",
    "cL": "\ud837\udf06",
    "d": "d",
    "d<": "\u0257",
    "d!": "\u01c0",
    "d-": "\u0256",
    "dH": "\u00f0",
    "e": "e",
    "e\"": "\u0259",
    "e)": "\u00f8",
    "e-": "\u0258",
    "f": "f",
    "g": "g",
    "g<": "\u0260",
    "g-": "\u0262",
    "gH": "\u0263",
    "gQ": "\uf001",
    "gJ": "\u025f",
    "gL": "\u029f",
    "h": "h",
    "h\"": "\u0266",
    "hH": "\u029c",
    "h+": "\u0127",
    "i": "i",
    "i\"": "\u0268",
    "j": "j",
    "jW": "\u0265",
    "jL": "\u028e",
    "jH": "\u029d",
    "k": "k",
    "l": "l",
    "l-": "\u026d",
    "l`": "\u027a",
    "l!": "\u01c1",
    "lS": "\u02aa",
    "lZ": "\u02ab",
    "m": "m",
    "m-": "\u0271",
    "n": "n",
    "n-": "\u0273",
    "nJ": "\u0272",
    "nG": "\u014b",
    "nQ": "\u0274",
    "o": "o",
    "o\"": "\u0275",
    "o(": "\u0264",
    "p": "p",
    "pH": "\u0278",
    "q": "q",
    "q<": "\u029b",
    "qR": "\u0280",
    "qQ": "\uf000",
    "r": "r",
    "r-": "\u027b",
    "rT": "\u027d",
    "r\"": "\u0279",
    "r|": "\ud837\udf0a",
    "rH": "\u0281",
    "r`": "\u027e",
    "r!": "\u203c",
    "s": "s",
    "s-": "\u0282",
    "sJ": "\u0255",
    "sL": "\u026c",
    "sH": "\u0283",
    "t": "t",
    "t!": "\u01c3",
    "t-": "\u0288",
    "tH": "\u03b8",
    "u": "u",
    "u\"": "\u0289",
    "u(": "\u026f",
    "v": "v",
    "vW": "\u028b",
    "v`": "\u2c71",
    "w": "w",
    "w(": "\u0270",
    "x": "x",
    "x-": "\u03c7",
    "xW": "\u028d",
    "xH": "\u0267",
    "xL": "\uf268",
    "y": "y",
    "z": "z",
    "zJ": "\u0291",
    "zL": "\u026e",
    "z-": "\u0290",
    "zH": "\u0292",
    "\n": "\n",
    "\t": "\t",
    "\r": "\r"
};

//This dictionary was generated programmatically with Python
var fa_graphemes ={
    "hW": "h",
    "b`": "\u1d5d",
    "b,": "\u1d66",
    "b'": "\u1d5d",
    "p`": "\u1db2",
    "p,": "\u1d69",
    "p'": "\u1db2",
    "v`": "\u1d5b",
    "v,": "\u1d65",
    "v'": "\u1d5b",
    "f`": "\u1da0",
    "f,": "\u1da0",
    "f'": "\u1da0",
    "d`": "\u1d9e",
    "d,": "\u1d9e",
    "d'": "\u1d9e",
    "t`": "\u0346",
    "t,": "\u032a",
    "t'": "\u1dbf",
    "z`": "\u1dbb",
    "z,": "\u02de",
    "z'": "\u02b4",
    "s`": "\u033f",
    "s,": "\u0333",
    "s'": "\u02e2",
    "n`": "\u1dbe",
    "n,": "\u1dbe",
    "n'": "\u1dbe",
    "$`": "\u1db4",
    "$,": "\u1db4",
    "$'": "\u1db4",
    "r`": "\u1dbc",
    "r,": "\u1dbc",
    "r'": "\u1dbc",
    "l`": "\u1db3",
    "l,": "\u1db3",
    "l'": "\u1db3",
    "j`": "\u1dbd",
    "j,": "\u2c7c",
    "j'": "\u02b2",
    "c`": "\u1d9d",
    "c,": "\u1d9c",
    "c'": "\u1d9c",
    "g`": "\u02e0",
    "g,": "\u1d67",
    "g'": "\u02e0",
    "k`": "\u02e3",
    "k,": "\u2093",
    "k'": "\u02e3",
    "G`": "\u02b6",
    "G,": "\u02b6",
    "G'": "\u02b6",
    "q`": "\u1d61",
    "q,": "\u1d6a",
    "q'": "\u1d61",
    "(`": "\u02e4",
    "(,": "\u0334",
    "('": "\u02e4",
    "?`": "\u1d34",
    "?,": "\ud801\udf95",
    "?'": "\u0334",
    "\"`": "\u02b1",
    "\",": "\u0324",
    "\"'": "\u02b1",
    "h`": "\u02b0",
    "h,": "\u2095",
    "h'": "\u02b0",
    "w`": "\u02b7",
    "w,": "\u02b7",
    "w'": "\u02b7",
    "x`": "\uab69",
    "x,": "\uab69",
    "x'": "\uab69",
    "y`": "\u1da3",
    "y,": "\u1da3",
    "y'": "\u1da3",
    "Y`": "\u1da3",
    "Y,": "\u1da3",
    "Y'": "\u1da3",
    "m`": "\u033c",
    "m,": "\u033c",
    "m'": "\u033c",
    "M`": "\u033c",
    "M,": "\u033c",
    "M'": "\u033c",
    "\\`": "\u02d5",
    "\\,": "\u031e",
    "\\'": "\u02d5",
    "^`": "\u1df5",
    "^,": "\u031d",
    "^'": "\u02d4",
    "}`": "\uab6b",
    "},": "\u0319",
    "}'": "\uab6b",
    "{`": "\uab6a",
    "{,": "\u0318",
    "{'": "\uab6a",
    "C`": "\u0311",
    "C,": "\u032f",
    "C'": "\u1d54",
    "+`": "\u02d6",
    "+,": "\u031f",
    "+'": "\u02d6",
    "-`": "\u02d7",
    "-,": "\u0320",
    "-'": "\u02d7",
    "8`": "\u02bc",
    "8,": "\u02bc",
    "8'": "\u02bc",
    "~`": "\u0303",
    "~,": "\u0330",
    "~'": "\u02dc",
    "_`": "\u02fd",
    "_,": "\u033a",
    "_'": "\u02fd",
    "=`": "\u033b",
    "=,": "\u033b",
    "='": "\u25ab",
    ":`": "\u033d",
    ":,": "\u2093",
    ":'": "\u02e3",
    ")`": "\u0357",
    "),": "\u0339",
    ")'": "\u02d2",
    "#`": "\u0351",
    "#,": "\u031c",
    "#'": "\u02d3",
    "0`": "\u030a",
    "0,": "\u0325",
    "0'": "\u02f3",
    "9`": "\u1da3",
    "9,": "\u1da3",
    "9'": "\u02ec",
    "V`": "\u030c",
    "V,": "\u032c",
    "V'": "\u1da3",
    "D`": "\u2193",
    "D,": "\u2193",
    "D'": "\u2193",
    "F`": "\u0330",
    "F,": "\u0330",
    "F'": "\u0330",
    "1`": "\u030f",
    "1,": "\u02f5",
    "1'": "\u02e9",
    "2`": "\u0300",
    "2,": "\u02ce",
    "2'": "\u02e8",
    "3`": "\u0304",
    "3,": "\u02cd",
    "3'": "\u02e7",
    "4`": "\u0301",
    "4,": "\u02cf",
    "4'": "\u02e6",
    "5`": "\u030b",
    "5,": "\u02f6",
    "5'": "\u02e5",
    "/N": "\u207f",
    "/7": "\u031a",
    "/J": "\u0361",
    "/L": "\u02e1",
    "/Z": "\ud801\udf9b",
    "/|": "\u0308",
    "0.": ".",
    "-.": "|",
    "=.": "\u2016",
    "+.": "\u02c8",
    "/.": "\u02cc",
    "&.": "\u0361",
    "_.": "\u035c",
    ":.": "\u02d0",
    ";.": "\u02d1",
    "%.": "\u0306",
    "V.": "\u02d0",
    "pP": "p",
    "bP": "b",
    "bN": "m",
    "bR": "\u0299",
    "bH": "\u03b2",
    "pH": "\u0278",
    "vN": "\u0271",
    "vT": "\u2c71",
    "fH": "f",
    "vH": "v",
    "vW": "\u028b",
    "tH": "\u03b8",
    "dH": "\u00f0",
    "sP": "t",
    "zP": "d",
    "zN": "n",
    "zR": "r",
    "zT": "\u027e",
    "sS": "s",
    "zS": "z",
    "cS": "\u0255",
    "jS": "\u0291",
    "sZ": "\u026c",
    "zZ": "\u026e",
    "zW": "\u0279",
    "zL": "l",
    "lP": "\u0288",
    "rP": "\u0256",
    "rN": "\u0273",
    "rT": "\u027d",
    "$S": "\u0283",
    "nS": "\u0292",
    "lS": "\u0282",
    "rS": "\u0290",
    "rW": "\u027b",
    "rL": "\u026d",
    "cP": "c",
    "jP": "\u025f",
    "jN": "\u0272",
    "cH": "\u00e7",
    "jH": "\u029d",
    "jW": "j",
    "jL": "\u028e",
    "kP": "k",
    "gP": "g",
    "gN": "\u014b",
    "kH": "x",
    "gH": "\u0263",
    "gW": "\u0270",
    "gL": "\u029f",
    "qP": "q",
    "GP": "\u0262",
    "GN": "\u0274",
    "GR": "\u0280",
    "qH": "\u03c7",
    "GH": "\u0281",
    "?H": "\u0127",
    "(H": "\u0295",
    "0K": "\u0294",
    "?P": "\u02a1",
    "hH": "h",
    "?R": "\u029c",
    "\"H": "\u0266",
    "(R": "\u02a2",
    "xH": "\u028d",
    "wW": "w",
    "yW": "\u0265",
    "lZ": "\ua78e",
    "xS": "\u0267",
    "pQ": "\u0298",
    "tQ": "\u01c0",
    "sQ": "\u01c3",
    "lQ": "\u203c",
    "cQ": "\u01c2",
    "bB": "\u0253",
    "zB": "\u0257",
    "jB": "\u0284",
    "gB": "\u0260",
    "GB": "\u029b",
    "z6": "\u027a",
    "z!": "\u01c1",
    "a<": "a",
    "e<": "e",
    "i<": "i",
    "o>": "o",
    "u>": "u",
    "u<": "y",
    "a>": "\u0251",
    "E<": "\u025b",
    "I[": "\u026a",
    "O>": "\u0254",
    "U]": "\u028a",
    "U[": "\u028f",
    "A<": "\u0276",
    "o<": "\u00f8",
    "e>": "\u0264",
    "i>": "\u026f",
    "A>": "\u0252",
    "O<": "\u0153",
    "E>": "\u028c",
    "@|": "\u0250",
    ":|": "\u0259",
    "i|": "\u0268",
    "o|": "\u0275",
    "u|": "\u0289",
    "E|": "\u025c",
    "e|": "\u0258",
    "O|": "\u025e",
    "@[": "\u00e6"
};

var input_mode = "tipo";
    
//When the page first loads, all the text boxes with IPA text start as
//having the "arial" class.
var current_font_class = 'arial';
//I didn't feel like having parse return a tuple, so I store whether or not
//there was an error here
var parsing_error = false;
var converter_textarea = document.querySelector("#text_input");
var block_submit = true;

//Make sure the input has text, but no Unicode characters.
//If it has unicode characters or no text, block form submission.
//A hint will be displayed when submission is blocked.
function validate_input() {
    let input_string = converter_textarea.value;
    let blocked = block_submit;
    //Default to enabling conversion.
    block_submit = false;

    //Block if the input is empty.
    if (input_string.length == 0) {
        block_submit = true;
        let hint = "Your input contains nothing. Please input something before conversion.";
        document.querySelector("#converter_output").textContent = hint;
        return;
    } 
    //https://stackoverflow.com/questions/1966476/how-can-i-process-each-letter-of-text-using-javascript
    for (let i = 0; i < input_string.length; i++) {
        //All Unicode characters that aren't ASCII are greater than 127.
        if (input_string.charCodeAt(i) > 127){
            block_submit = true;
            let hint = "Your input contains non-ASCII characters, which is invalid.";
            document.querySelector("#converter_output").textContent = hint;
            return;
        }
    }
    //We only want to clear the output if the input was invalid beforehand.
    //Otherwise, we might clear a previous conversion.
    if (blocked) {
        document.querySelector("#converter_output").textContent = "";
    }
};

//We validate on page start incase the browser keeps the input from last
//session.
validate_input();

//Generate an error message.
//input = The erroneous input.
//i = The index (number) where the error occurred in the input.
//Returns an error message string meant to be put into an innerHTML.
function error_message(input, i) {
    //https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals
    let error_msg = `There was an error at character ${i}:<br><br>`;

    //On top of giving the index, we show the input with the
    //erroneous character emphasized.
        
    //We must avoid users putting in html code that works.
    //Thus, we replace all less than and greater than characters with a
    //version of them that can't be used to create element tags.
    //We do this to the characters left of the bad character first.
    let left = input.substring(0, i);
    //https://en.wikipedia.org/wiki/Private_Use_Areas
    //https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/replaceAll
    left = left.replaceAll("<", "\uF8FF");
    //https://developer.mozilla.org/en-US/docs/Web/HTML/Element/pre
    left = left.replaceAll(">", "<pre style=\"display: inline\">&gt;</pre>");
    left = left.replaceAll("\uF8FF",
        "<pre style=\"display: inline\">&lt;</pre>");
    error_msg += left
    //We wanna make the erroneous character stand out.
    error_msg += "<strong><em><u>" + input.substring(i, i+1);
    error_msg += "</strong></em></u>";
    //If there is more input after the erroneous character, do to it what
    //we did to the input left of the character.
    if (i != input.length - 1) {
        let right = input.substr(i + 1, input.length);
        right = right.replaceAll("<", "\uF8FF");
        right = right.replaceAll(">",
            "<pre style=\"display: inline\">&gt;</pre>");
        right = right.replaceAll("\uF8FF",
            "<pre style=\"display: inline\">&lt;</pre>");
        error_msg += right;
    }

    return error_msg;
}

//https://www.w3schools.com/js/js_functions.asp
//Convert the input TIPO string to IPA and return it.
//input = A string. Meant to be valid TIPO, but will handle it if it's not.
//Returns a string of IPA characters.
function parse_tipo(input){
    //Some context for non-phoneticians:
    //Grapheme = unit of writing representing a single sound
    //e.g. In English, "s", "sh", and "h" are single graphemes.
    //Digraph = A grapheme consisting of two symbols.
    //Monograph = A grapheme consisting of one symbol.

    //Start by assuming there was no error
    parsing_error = false;

    //https://www.w3schools.com/js/js_if_else.asp
    //https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/length
    //"" in TIPO is "" in IPA
    if (input.length == 0){
        return input;
    }
        
    let output = "";
    //We cache whether or not the last scanned grapheme was a digraph so
    //we can make some checks after the while loop.
    let last_digraph = false;
    let i = 0;
    //https://www.w3schools.com/js/js_loop_while.asp
    //We shouldn't use a for loop, since we don't always increment by a fixed
    //amount every iteration
    while (i < input.length - 1) {
        //https://www.w3schools.com/jsref/jsref_substring.asp
        //https://sentry.io/answers/difference-between-let-and-var-in-javascript/
        let substr = input.substring(i,i+2);
        let digraph_result = tipo_graphemes[substr];
        
        //https://stackoverflow.com/questions/19317943/why-referencing-non-existent-property-of-an-object-in-javascript-doesnt-return
        //We check for graphemes of length 2 first, since digraphs can
        //and almost always do contain a valid monograph.
        //Also, if a object does not have what we query it for, the result is
        //false-y/null-y. If it's not null, our digraph exists.
        if (digraph_result != null) {
            last_digraph = true;
            output += digraph_result;
            i += 2;
        } else {
            last_digraph = false;
            let substr = input.substring(i, i+1);
            let monograph_result = tipo_graphemes[substr];
            if (monograph_result != null) {
                output += monograph_result;
                i += 1;
            //If neither the digraph or monograph exist, that means the input
            //is not valid TIPO. We let the user know where the error was
            //so they can fix it.
            }else {
                parsing_error = true;
                return error_message(input, i);
            }
        }
    }

    let substr = input.substring(input.length - 1, input.length);
    let monograph_result = tipo_graphemes[substr];
    let semifinal_backslash = (input.length > 1 &&
        input.substring(input.length - 2, input.length - 1) == '\\');
    let semifinal_double_backslash = (input.length > 2 &&
        input.substring(input.length - 3, input.length - 1) === '\\\\');
    //We ignore the last character if it was preceded by a backslash,
    //since that's used as an escape character, possibly used with
    //"primary" characters (characters that are first in digraphs).
    //However, there's an edge case where the last 2 characters are backslashes
    //which should result in the last character being its own grapheme.
    if (monograph_result != null &&
        !(semifinal_backslash && !semifinal_double_backslash)){
        output += monograph_result;
    } else{
        //Technically, if the last grapheme was a digraph, our last character
        //won't be a valid monograph unless it was \ + an ascii character.
        //Regardless, we want to ignore the second character, since it was
        //already used.
        //However, if the second to last character was a monograph, and we
        //still have a non-monographic character at the end, that means
        //that the input was invalid.
        if (!last_digraph) {
            parsing_error = true;
            return error_message(input, i);
        } 
    }

    return output;
}

//https://www.w3schools.com/js/js_functions.asp
//Convert the input FA string to IPA and return it.
//input = A string. Meant to be valid FA, but will handle it if it's not.
//Returns a string of IPA characters.
function parse_fa(input){
    let whitespace = new Set([" ", "\n", "\t", "\r"]);
    //Some context for non-phoneticians:
    //Grapheme = unit of writing representing a single sound
    //e.g. In English, "s", "sh", and "h" are single graphemes.
    //Digraph = A grapheme consisting of two symbols.
    //Monograph = A grapheme consisting of one symbol.

    //Start by assuming there was no error
    parsing_error = false;

    //"" in FA is "" in IPA
    if (input.length == 0){
        return input;
    }
        
    let output = "";
    //We cache whether or not the last scanned grapheme was a digraph so
    //we can make some checks after the while loop.
    let last_digraph = false;
    let i = 0;

    //We shouldn't use a for loop, since we don't always increment by a fixed
    //amount every iteration
    while (i < input.length - 1) {
        let substr = input.substring(i,i+2);
        console.log(substr.charAt(0));
        //Whitespace characters are the only single byte graphemes.
        if (whitespace.has(substr.charAt(0))) {
            output += substr.charAt(0);
            i += 1;
            continue;
        }
        let digraph_result = fa_graphemes[substr];
        
        //All non-whitespace graphemes have two characters.
        if (digraph_result != null) {
            last_digraph = true;
            output += digraph_result;
            i += 2;
        } else {
            last_digraph =  false;
            parsing_error = true;
            return error_message(input, i);
        }
    }

    let substr = input.substring(input.length - 1, input.length);

    if (whitespace.has(substr)) {
        output += substr;
    } else {
        //If last_digraph is true, and the last character wasn't whitespace,
        //then the character is some other monograph which is invalid.
        if (!last_digraph){
            parsing_error = true;
            return error_message(input, input.length - 1);
        }
    }

    return output;
}

//Switch the font of all text whose purpose is to display IPA text.
function switch_fonts() {
    //We need to get the new font from the form.
    let converter_form = document.getElementById("ascii_converter");
    //https://developer.mozilla.org/en-US/docs/Web/API/FormData/get
    let form_data = new FormData(converter_form);
    //Cache the old font class for comparison.
    let old_font_class = current_font_class
    let ipa_texts = document.getElementsByClassName(old_font_class);
    current_font_class = form_data.get("ipa_font");

    //If we don't make this check, the while loop inside could go infinitely
    if (old_font_class != current_font_class) {
        //https://stackoverflow.com/questions/54404940/set-attributes-of-html-tag-using-pure-javascript
        //Apparently, the result of `getElementsByClassName`changes based on
        //the current state of the page and not the state when it was called.
        //Therefore, we need a while loop and not a for loop. I found this out
        //by debugging.
        do {
            ipa_texts[0].className = current_font_class;
        } while (ipa_texts.length > 0)
    }
}

//Given the size of the TIPO input and IPA output in bytes, display a
//message describing the difference between the two in detail.
//Also, mention that the conversion was either a failure or success.
//The message will be put into the element with id #size_difference.
//input_size = The number of bytes in the TIPO input.
//output_size = The number of bytes in the IPA output.
function display_size_difference(input_size, output_size) {
        let size_diff = output_size - input_size;
    
        //Generate the string for the size difference, wrapping the difference in
        //a <strong> tag.
        let size_str = "Conversion failed; there's no difference to show.";
        //There's no point in making a comparison with an error message.
        if (!parsing_error) {
            size_str = "<strong>Conversion successful!</strong>";
            size_str += "<br>The output has <strong>";
            if (size_diff > 0) {
                size_str += size_diff + "</strong> more bytes than the input";
                //https://stackoverflow.com/questions/11832914/how-to-round-to-at-most-2-decimal-places-if-necessary
                size_str += "<em> (" + (output_size*100/input_size ).toFixed(1);
                size_str += "% bigger)</em>.";
            } else if (size_diff < 0) {
                size_str += -1*size_diff;
                size_str +=  "</strong> less bytes than the input";
                size_str += "<em> (" + (input_size*100/output_size ).toFixed(1);
                size_str += "% smaller)</em>.";
            } else {
                size_str += " the same</strong> number of bytes as the input.";
            }
        }
        
        //We use innerHTML instead of textContent so that the strong tags work.
        document.querySelector("#size_difference").innerHTML = size_str;
}

//Clear the current text of ALL textarea elements on the page.
function clear_textareas() {
    let textareas = document.getElementsByTagName('textarea');

    //https://www.w3schools.com/js/js_loop_for.asp
    for (let i = 0; i < textareas.length; i++) {
        //https://stackoverflow.com/questions/14939010/get-value-from-text-area
        textareas[i].value = "";
    }
}

//Take input from the text area, parse it, and display the corresponding IPA.
//Additionally, display the difference in size between the input and output.
//Returns false for the sake of staying on the page after form submission.
function input_to_output() {
    let converter_form = document.getElementById("ascii_converter");
    //https://developer.mozilla.org/en-US/docs/Web/API/FormData/get
    let form_data = new FormData(converter_form);
    let input = form_data.get("text_input");
    let input_mode = form_data.get("input_system");
    var output = "";
    switch (input_mode) {
        case "tipo":
            output = parse_tipo(form_data.get("text_input"));
            break;
        case "fa":
            output = parse_fa(form_data.get("text_input"));
            break;
        default:
            output = parse_tipo(form_data.get("text_input"));
            break;
    }

    //https://labex.io/tutorials/javascript-calculating-string-byte-size-28182
    display_size_difference(new Blob([input]).size, new Blob([output]).size);

    //There's also no point in wrapping the error message with anything.
    if (!parsing_error) {
        let wrapper = form_data.get("wrapper");

        switch (wrapper){
            case "apostrophes":
                output = "'" + output + "'";
                break;
            case "quotes":
                output = '"' + output + '"';
                break;
            case "slashes":
                output = '/' + output + '/';
                break;
            case "brackets":
                output = '[' + output + ']';
                break;
            default:
                break;
        }
    }

    if (!parsing_error) {
        //We change the textContent out the output paragraph because we are not
        //formatting it with tags at all.
        document.getElementById("converter_output").textContent = output;
    } else {
        //However, there is formatting in the error message.
        document.getElementById("converter_output").innerHTML = output;
    }

    //https://www.w3schools.com/howto/howto_js_copy_clipboard.asp
    //We don't want to have the user copy something unexpectedly.
    if (form_data.get("copy") == "yes" && !parsing_error) {
        navigator.clipboard.writeText(output);
    }

    //https://stackoverflow.com/questions/64619241/how-do-you-change-a-html-text-after-form-submission
    return false;
}

var input_system_dropdown = document.querySelector("#input_system_select")
function set_input_mode () {
    input_mode = input_system_dropdown.value
    let input_label = document.querySelector("#input_system_label");
    switch (input_mode) {
        case "tipo":
            input_label.firstChild.href = "https://docs.google.com/document/d/1iQWEtJ35SSIBtPZA9xKoJoD6rnc6tHB_05NQ4WwEPW0/edit?usp=sharing";
            break;
        case "fa":
            input_label.firstChild.href = "https://docs.google.com/document/d/1-CyNvwR1_rhjHadXS3ph9-NSp25RyVNgANfu9MxTMCg/edit?usp=sharing";
            break;
        default:
            input_label.firstChild.href = "https://docs.google.com/document/d/1iQWEtJ35SSIBtPZA9xKoJoD6rnc6tHB_05NQ4WwEPW0/edit?usp=sharing";
            break;
    }
};

input_system_dropdown.addEventListener("change", set_input_mode);
document.querySelector("#ipa_font_select").addEventListener("change", switch_fonts);
document.querySelector("#clear_button").addEventListener("click", clear_textareas);
document.querySelector("#ascii_converter").addEventListener("submit", function(event){
    event.preventDefault();
    if (!block_submit){
        input_to_output();
    }
});

//Display a tip on putting in input when the user clicks the textarea.
//Only do this if it's empty.
converter_textarea.addEventListener("focus", function(){
    console.log(converter_textarea.value);
    if (converter_textarea.value == "") {
        let hint = "Type something in the box to convert. ";
        hint += "The input must only be in ASCII. It should also match ";
        hint += "the writing system you chose. Otherwise, you will get an ";
        hint += "error message.";
        document.querySelector("#converter_output").textContent = hint;
        block_submit=true;
    }
});

//After blurring, make sure the input has no Unicode characters.
//If it does, block form submission.
converter_textarea.addEventListener("blur", validate_input);